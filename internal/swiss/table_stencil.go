// Copyright 2020-2025 Buf Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package swiss

// Code generated by internal/stencil. DO NOT EDIT

import (
	"bytes"

	"math/rand/v2"

	"github.com/bufbuild/fastpb/internal/dbg"
	"github.com/bufbuild/fastpb/internal/unsafe2"
)

func InitU8xU8(t *Table[uint8, uint8], len int, from *Table[uint8, uint8], extract func(uint8) []byte) *Table[uint8, uint8] {
	_ = (*Table[uint8, uint8]).Init
	t.soft, t.hard = loadFactor(len)
	t.seed = fxhash(rand.Uint64())

	if from == nil || from.len == 0 {
		return t
	}

	ctrl1 := from.ctrl()
	keys1 := from.keys()
	vals1 := from.values()

	ctrl2 := unsafe2.Cast[unsafe2.VLA[byte]](t.ctrl())
	keys2 := t.keys()
	vals2 := t.values()

	if extract == nil {
		for i := 0; ; i++ {
			dbg.Assert(i < int(t.hard/8), "infinite loop during copy")

			ctrl := *ctrl1.Get(i)
			for j := range 8 {
				if ctrl&0xff == empty {
					continue
				}
				ctrl >>= 8

				n := i*8 + j
				k := *keys1.Get(n)
				h := t.seed.u64(zext(k))
				idx, occupied := searchU8xU8(t, h, k)
				dbg.Assert(!occupied, "fwo keys mapped to one slot")

				*ctrl2.Get(idx) = h.h2()
				*keys2.Get(idx) = *keys1.Get(n)
				*vals2.Get(idx) = *vals1.Get(n)
				t.len++

				if t.len == from.len {
					return t
				}
			}
		}
	} else {
		for i := 0; ; i++ {
			dbg.Assert(i < int(t.hard/8), "infinite loop during copy")

			ctrl := *ctrl1.Get(i)
			for j := range 8 {
				if ctrl&0xff == empty {
					continue
				}
				ctrl >>= 8

				n := i*8 + j
				k := extract(*keys1.Get(n))
				h := t.seed.bytes(k)
				idx, occupied := searchFuncU8xU8(t, h, k, extract)
				dbg.Assert(!occupied, "fwo keys mapped to one slot")

				*ctrl2.Get(idx) = h.h2()
				*keys2.Get(idx) = *keys1.Get(n)
				*vals2.Get(idx) = *vals1.Get(n)
				t.len++

				if t.len == from.len {
					return t
				}
			}
		}
	}
}

func InitU32xU8(t *Table[uint32, uint8], len int, from *Table[uint32, uint8], extract func(uint32) []byte) *Table[uint32, uint8] {
	_ = (*Table[uint32, uint8]).Init
	t.soft, t.hard = loadFactor(len)
	t.seed = fxhash(rand.Uint64())

	if from == nil || from.len == 0 {
		return t
	}

	ctrl1 := from.ctrl()
	keys1 := from.keys()
	vals1 := from.values()

	ctrl2 := unsafe2.Cast[unsafe2.VLA[byte]](t.ctrl())
	keys2 := t.keys()
	vals2 := t.values()

	if extract == nil {
		for i := 0; ; i++ {
			dbg.Assert(i < int(t.hard/8), "infinite loop during copy")

			ctrl := *ctrl1.Get(i)
			for j := range 8 {
				if ctrl&0xff == empty {
					continue
				}
				ctrl >>= 8

				n := i*8 + j
				k := *keys1.Get(n)
				h := t.seed.u64(zext(k))
				idx, occupied := searchU32xU8(t, h, k)
				dbg.Assert(!occupied, "fwo keys mapped to one slot")

				*ctrl2.Get(idx) = h.h2()
				*keys2.Get(idx) = *keys1.Get(n)
				*vals2.Get(idx) = *vals1.Get(n)
				t.len++

				if t.len == from.len {
					return t
				}
			}
		}
	} else {
		for i := 0; ; i++ {
			dbg.Assert(i < int(t.hard/8), "infinite loop during copy")

			ctrl := *ctrl1.Get(i)
			for j := range 8 {
				if ctrl&0xff == empty {
					continue
				}
				ctrl >>= 8

				n := i*8 + j
				k := extract(*keys1.Get(n))
				h := t.seed.bytes(k)
				idx, occupied := searchFuncU32xU8(t, h, k, extract)
				dbg.Assert(!occupied, "fwo keys mapped to one slot")

				*ctrl2.Get(idx) = h.h2()
				*keys2.Get(idx) = *keys1.Get(n)
				*vals2.Get(idx) = *vals1.Get(n)
				t.len++

				if t.len == from.len {
					return t
				}
			}
		}
	}
}

func InitU64xU8(t *Table[uint64, uint8], len int, from *Table[uint64, uint8], extract func(uint64) []byte) *Table[uint64, uint8] {
	_ = (*Table[uint64, uint8]).Init
	t.soft, t.hard = loadFactor(len)
	t.seed = fxhash(rand.Uint64())

	if from == nil || from.len == 0 {
		return t
	}

	ctrl1 := from.ctrl()
	keys1 := from.keys()
	vals1 := from.values()

	ctrl2 := unsafe2.Cast[unsafe2.VLA[byte]](t.ctrl())
	keys2 := t.keys()
	vals2 := t.values()

	if extract == nil {
		for i := 0; ; i++ {
			dbg.Assert(i < int(t.hard/8), "infinite loop during copy")

			ctrl := *ctrl1.Get(i)
			for j := range 8 {
				if ctrl&0xff == empty {
					continue
				}
				ctrl >>= 8

				n := i*8 + j
				k := *keys1.Get(n)
				h := t.seed.u64(zext(k))
				idx, occupied := searchU64xU8(t, h, k)
				dbg.Assert(!occupied, "fwo keys mapped to one slot")

				*ctrl2.Get(idx) = h.h2()
				*keys2.Get(idx) = *keys1.Get(n)
				*vals2.Get(idx) = *vals1.Get(n)
				t.len++

				if t.len == from.len {
					return t
				}
			}
		}
	} else {
		for i := 0; ; i++ {
			dbg.Assert(i < int(t.hard/8), "infinite loop during copy")

			ctrl := *ctrl1.Get(i)
			for j := range 8 {
				if ctrl&0xff == empty {
					continue
				}
				ctrl >>= 8

				n := i*8 + j
				k := extract(*keys1.Get(n))
				h := t.seed.bytes(k)
				idx, occupied := searchFuncU64xU8(t, h, k, extract)
				dbg.Assert(!occupied, "fwo keys mapped to one slot")

				*ctrl2.Get(idx) = h.h2()
				*keys2.Get(idx) = *keys1.Get(n)
				*vals2.Get(idx) = *vals1.Get(n)
				t.len++

				if t.len == from.len {
					return t
				}
			}
		}
	}
}

func InitU8xU32(t *Table[uint8, uint32], len int, from *Table[uint8, uint32], extract func(uint8) []byte) *Table[uint8, uint32] {
	_ = (*Table[uint8, uint32]).Init
	t.soft, t.hard = loadFactor(len)
	t.seed = fxhash(rand.Uint64())

	if from == nil || from.len == 0 {
		return t
	}

	ctrl1 := from.ctrl()
	keys1 := from.keys()
	vals1 := from.values()

	ctrl2 := unsafe2.Cast[unsafe2.VLA[byte]](t.ctrl())
	keys2 := t.keys()
	vals2 := t.values()

	if extract == nil {
		for i := 0; ; i++ {
			dbg.Assert(i < int(t.hard/8), "infinite loop during copy")

			ctrl := *ctrl1.Get(i)
			for j := range 8 {
				if ctrl&0xff == empty {
					continue
				}
				ctrl >>= 8

				n := i*8 + j
				k := *keys1.Get(n)
				h := t.seed.u64(zext(k))
				idx, occupied := searchU8xU32(t, h, k)
				dbg.Assert(!occupied, "fwo keys mapped to one slot")

				*ctrl2.Get(idx) = h.h2()
				*keys2.Get(idx) = *keys1.Get(n)
				*vals2.Get(idx) = *vals1.Get(n)
				t.len++

				if t.len == from.len {
					return t
				}
			}
		}
	} else {
		for i := 0; ; i++ {
			dbg.Assert(i < int(t.hard/8), "infinite loop during copy")

			ctrl := *ctrl1.Get(i)
			for j := range 8 {
				if ctrl&0xff == empty {
					continue
				}
				ctrl >>= 8

				n := i*8 + j
				k := extract(*keys1.Get(n))
				h := t.seed.bytes(k)
				idx, occupied := searchFuncU8xU32(t, h, k, extract)
				dbg.Assert(!occupied, "fwo keys mapped to one slot")

				*ctrl2.Get(idx) = h.h2()
				*keys2.Get(idx) = *keys1.Get(n)
				*vals2.Get(idx) = *vals1.Get(n)
				t.len++

				if t.len == from.len {
					return t
				}
			}
		}
	}
}

func InitU32xU32(t *Table[uint32, uint32], len int, from *Table[uint32, uint32], extract func(uint32) []byte) *Table[uint32, uint32] {
	_ = (*Table[uint32, uint32]).Init
	t.soft, t.hard = loadFactor(len)
	t.seed = fxhash(rand.Uint64())

	if from == nil || from.len == 0 {
		return t
	}

	ctrl1 := from.ctrl()
	keys1 := from.keys()
	vals1 := from.values()

	ctrl2 := unsafe2.Cast[unsafe2.VLA[byte]](t.ctrl())
	keys2 := t.keys()
	vals2 := t.values()

	if extract == nil {
		for i := 0; ; i++ {
			dbg.Assert(i < int(t.hard/8), "infinite loop during copy")

			ctrl := *ctrl1.Get(i)
			for j := range 8 {
				if ctrl&0xff == empty {
					continue
				}
				ctrl >>= 8

				n := i*8 + j
				k := *keys1.Get(n)
				h := t.seed.u64(zext(k))
				idx, occupied := searchU32xU32(t, h, k)
				dbg.Assert(!occupied, "fwo keys mapped to one slot")

				*ctrl2.Get(idx) = h.h2()
				*keys2.Get(idx) = *keys1.Get(n)
				*vals2.Get(idx) = *vals1.Get(n)
				t.len++

				if t.len == from.len {
					return t
				}
			}
		}
	} else {
		for i := 0; ; i++ {
			dbg.Assert(i < int(t.hard/8), "infinite loop during copy")

			ctrl := *ctrl1.Get(i)
			for j := range 8 {
				if ctrl&0xff == empty {
					continue
				}
				ctrl >>= 8

				n := i*8 + j
				k := extract(*keys1.Get(n))
				h := t.seed.bytes(k)
				idx, occupied := searchFuncU32xU32(t, h, k, extract)
				dbg.Assert(!occupied, "fwo keys mapped to one slot")

				*ctrl2.Get(idx) = h.h2()
				*keys2.Get(idx) = *keys1.Get(n)
				*vals2.Get(idx) = *vals1.Get(n)
				t.len++

				if t.len == from.len {
					return t
				}
			}
		}
	}
}

func InitU64xU32(t *Table[uint64, uint32], len int, from *Table[uint64, uint32], extract func(uint64) []byte) *Table[uint64, uint32] {
	_ = (*Table[uint64, uint32]).Init
	t.soft, t.hard = loadFactor(len)
	t.seed = fxhash(rand.Uint64())

	if from == nil || from.len == 0 {
		return t
	}

	ctrl1 := from.ctrl()
	keys1 := from.keys()
	vals1 := from.values()

	ctrl2 := unsafe2.Cast[unsafe2.VLA[byte]](t.ctrl())
	keys2 := t.keys()
	vals2 := t.values()

	if extract == nil {
		for i := 0; ; i++ {
			dbg.Assert(i < int(t.hard/8), "infinite loop during copy")

			ctrl := *ctrl1.Get(i)
			for j := range 8 {
				if ctrl&0xff == empty {
					continue
				}
				ctrl >>= 8

				n := i*8 + j
				k := *keys1.Get(n)
				h := t.seed.u64(zext(k))
				idx, occupied := searchU64xU32(t, h, k)
				dbg.Assert(!occupied, "fwo keys mapped to one slot")

				*ctrl2.Get(idx) = h.h2()
				*keys2.Get(idx) = *keys1.Get(n)
				*vals2.Get(idx) = *vals1.Get(n)
				t.len++

				if t.len == from.len {
					return t
				}
			}
		}
	} else {
		for i := 0; ; i++ {
			dbg.Assert(i < int(t.hard/8), "infinite loop during copy")

			ctrl := *ctrl1.Get(i)
			for j := range 8 {
				if ctrl&0xff == empty {
					continue
				}
				ctrl >>= 8

				n := i*8 + j
				k := extract(*keys1.Get(n))
				h := t.seed.bytes(k)
				idx, occupied := searchFuncU64xU32(t, h, k, extract)
				dbg.Assert(!occupied, "fwo keys mapped to one slot")

				*ctrl2.Get(idx) = h.h2()
				*keys2.Get(idx) = *keys1.Get(n)
				*vals2.Get(idx) = *vals1.Get(n)
				t.len++

				if t.len == from.len {
					return t
				}
			}
		}
	}
}

func InitU8xU64(t *Table[uint8, uint64], len int, from *Table[uint8, uint64], extract func(uint8) []byte) *Table[uint8, uint64] {
	_ = (*Table[uint8, uint64]).Init
	t.soft, t.hard = loadFactor(len)
	t.seed = fxhash(rand.Uint64())

	if from == nil || from.len == 0 {
		return t
	}

	ctrl1 := from.ctrl()
	keys1 := from.keys()
	vals1 := from.values()

	ctrl2 := unsafe2.Cast[unsafe2.VLA[byte]](t.ctrl())
	keys2 := t.keys()
	vals2 := t.values()

	if extract == nil {
		for i := 0; ; i++ {
			dbg.Assert(i < int(t.hard/8), "infinite loop during copy")

			ctrl := *ctrl1.Get(i)
			for j := range 8 {
				if ctrl&0xff == empty {
					continue
				}
				ctrl >>= 8

				n := i*8 + j
				k := *keys1.Get(n)
				h := t.seed.u64(zext(k))
				idx, occupied := searchU8xU64(t, h, k)
				dbg.Assert(!occupied, "fwo keys mapped to one slot")

				*ctrl2.Get(idx) = h.h2()
				*keys2.Get(idx) = *keys1.Get(n)
				*vals2.Get(idx) = *vals1.Get(n)
				t.len++

				if t.len == from.len {
					return t
				}
			}
		}
	} else {
		for i := 0; ; i++ {
			dbg.Assert(i < int(t.hard/8), "infinite loop during copy")

			ctrl := *ctrl1.Get(i)
			for j := range 8 {
				if ctrl&0xff == empty {
					continue
				}
				ctrl >>= 8

				n := i*8 + j
				k := extract(*keys1.Get(n))
				h := t.seed.bytes(k)
				idx, occupied := searchFuncU8xU64(t, h, k, extract)
				dbg.Assert(!occupied, "fwo keys mapped to one slot")

				*ctrl2.Get(idx) = h.h2()
				*keys2.Get(idx) = *keys1.Get(n)
				*vals2.Get(idx) = *vals1.Get(n)
				t.len++

				if t.len == from.len {
					return t
				}
			}
		}
	}
}

func InitU32xU64(t *Table[uint32, uint64], len int, from *Table[uint32, uint64], extract func(uint32) []byte) *Table[uint32, uint64] {
	_ = (*Table[uint32, uint64]).Init
	t.soft, t.hard = loadFactor(len)
	t.seed = fxhash(rand.Uint64())

	if from == nil || from.len == 0 {
		return t
	}

	ctrl1 := from.ctrl()
	keys1 := from.keys()
	vals1 := from.values()

	ctrl2 := unsafe2.Cast[unsafe2.VLA[byte]](t.ctrl())
	keys2 := t.keys()
	vals2 := t.values()

	if extract == nil {
		for i := 0; ; i++ {
			dbg.Assert(i < int(t.hard/8), "infinite loop during copy")

			ctrl := *ctrl1.Get(i)
			for j := range 8 {
				if ctrl&0xff == empty {
					continue
				}
				ctrl >>= 8

				n := i*8 + j
				k := *keys1.Get(n)
				h := t.seed.u64(zext(k))
				idx, occupied := searchU32xU64(t, h, k)
				dbg.Assert(!occupied, "fwo keys mapped to one slot")

				*ctrl2.Get(idx) = h.h2()
				*keys2.Get(idx) = *keys1.Get(n)
				*vals2.Get(idx) = *vals1.Get(n)
				t.len++

				if t.len == from.len {
					return t
				}
			}
		}
	} else {
		for i := 0; ; i++ {
			dbg.Assert(i < int(t.hard/8), "infinite loop during copy")

			ctrl := *ctrl1.Get(i)
			for j := range 8 {
				if ctrl&0xff == empty {
					continue
				}
				ctrl >>= 8

				n := i*8 + j
				k := extract(*keys1.Get(n))
				h := t.seed.bytes(k)
				idx, occupied := searchFuncU32xU64(t, h, k, extract)
				dbg.Assert(!occupied, "fwo keys mapped to one slot")

				*ctrl2.Get(idx) = h.h2()
				*keys2.Get(idx) = *keys1.Get(n)
				*vals2.Get(idx) = *vals1.Get(n)
				t.len++

				if t.len == from.len {
					return t
				}
			}
		}
	}
}

func InitU64xU64(t *Table[uint64, uint64], len int, from *Table[uint64, uint64], extract func(uint64) []byte) *Table[uint64, uint64] {
	_ = (*Table[uint64, uint64]).Init
	t.soft, t.hard = loadFactor(len)
	t.seed = fxhash(rand.Uint64())

	if from == nil || from.len == 0 {
		return t
	}

	ctrl1 := from.ctrl()
	keys1 := from.keys()
	vals1 := from.values()

	ctrl2 := unsafe2.Cast[unsafe2.VLA[byte]](t.ctrl())
	keys2 := t.keys()
	vals2 := t.values()

	if extract == nil {
		for i := 0; ; i++ {
			dbg.Assert(i < int(t.hard/8), "infinite loop during copy")

			ctrl := *ctrl1.Get(i)
			for j := range 8 {
				if ctrl&0xff == empty {
					continue
				}
				ctrl >>= 8

				n := i*8 + j
				k := *keys1.Get(n)
				h := t.seed.u64(zext(k))
				idx, occupied := searchU64xU64(t, h, k)
				dbg.Assert(!occupied, "fwo keys mapped to one slot")

				*ctrl2.Get(idx) = h.h2()
				*keys2.Get(idx) = *keys1.Get(n)
				*vals2.Get(idx) = *vals1.Get(n)
				t.len++

				if t.len == from.len {
					return t
				}
			}
		}
	} else {
		for i := 0; ; i++ {
			dbg.Assert(i < int(t.hard/8), "infinite loop during copy")

			ctrl := *ctrl1.Get(i)
			for j := range 8 {
				if ctrl&0xff == empty {
					continue
				}
				ctrl >>= 8

				n := i*8 + j
				k := extract(*keys1.Get(n))
				h := t.seed.bytes(k)
				idx, occupied := searchFuncU64xU64(t, h, k, extract)
				dbg.Assert(!occupied, "fwo keys mapped to one slot")

				*ctrl2.Get(idx) = h.h2()
				*keys2.Get(idx) = *keys1.Get(n)
				*vals2.Get(idx) = *vals1.Get(n)
				t.len++

				if t.len == from.len {
					return t
				}
			}
		}
	}
}

func InsertU8xU8(t *Table[uint8, uint8], k uint8, extract func(uint8) []byte) *uint8 {
	_ = (*Table[uint8, uint8]).Insert
	if t.len == t.soft {
		return nil
	}

	var idx int
	var occupied bool
	var h fxhash
	if extract == nil {
		h = t.seed.u64(zext(k))
		idx, occupied = searchU8xU8(t, h, k)
	} else {
		k := extract(k)
		h = t.seed.bytes(k)
		idx, occupied = searchFuncU8xU8(t, h, k, extract)
	}
	if !occupied {
		ctrl := unsafe2.Cast[unsafe2.VLA[byte]](t.ctrl())
		*ctrl.Get(idx) = h.h2()
		*t.keys().Get(idx) = k
		t.len++
	}
	return t.values().Get(idx)
}

func InsertU32xU8(t *Table[uint32, uint8], k uint32, extract func(uint32) []byte) *uint8 {
	_ = (*Table[uint32, uint8]).Insert
	if t.len == t.soft {
		return nil
	}

	var idx int
	var occupied bool
	var h fxhash
	if extract == nil {
		h = t.seed.u64(zext(k))
		idx, occupied = searchU32xU8(t, h, k)
	} else {
		k := extract(k)
		h = t.seed.bytes(k)
		idx, occupied = searchFuncU32xU8(t, h, k, extract)
	}
	if !occupied {
		ctrl := unsafe2.Cast[unsafe2.VLA[byte]](t.ctrl())
		*ctrl.Get(idx) = h.h2()
		*t.keys().Get(idx) = k
		t.len++
	}
	return t.values().Get(idx)
}

func InsertU64xU8(t *Table[uint64, uint8], k uint64, extract func(uint64) []byte) *uint8 {
	_ = (*Table[uint64, uint8]).Insert
	if t.len == t.soft {
		return nil
	}

	var idx int
	var occupied bool
	var h fxhash
	if extract == nil {
		h = t.seed.u64(zext(k))
		idx, occupied = searchU64xU8(t, h, k)
	} else {
		k := extract(k)
		h = t.seed.bytes(k)
		idx, occupied = searchFuncU64xU8(t, h, k, extract)
	}
	if !occupied {
		ctrl := unsafe2.Cast[unsafe2.VLA[byte]](t.ctrl())
		*ctrl.Get(idx) = h.h2()
		*t.keys().Get(idx) = k
		t.len++
	}
	return t.values().Get(idx)
}

func InsertU8xU32(t *Table[uint8, uint32], k uint8, extract func(uint8) []byte) *uint32 {
	_ = (*Table[uint8, uint32]).Insert
	if t.len == t.soft {
		return nil
	}

	var idx int
	var occupied bool
	var h fxhash
	if extract == nil {
		h = t.seed.u64(zext(k))
		idx, occupied = searchU8xU32(t, h, k)
	} else {
		k := extract(k)
		h = t.seed.bytes(k)
		idx, occupied = searchFuncU8xU32(t, h, k, extract)
	}
	if !occupied {
		ctrl := unsafe2.Cast[unsafe2.VLA[byte]](t.ctrl())
		*ctrl.Get(idx) = h.h2()
		*t.keys().Get(idx) = k
		t.len++
	}
	return t.values().Get(idx)
}

func InsertU32xU32(t *Table[uint32, uint32], k uint32, extract func(uint32) []byte) *uint32 {
	_ = (*Table[uint32, uint32]).Insert
	if t.len == t.soft {
		return nil
	}

	var idx int
	var occupied bool
	var h fxhash
	if extract == nil {
		h = t.seed.u64(zext(k))
		idx, occupied = searchU32xU32(t, h, k)
	} else {
		k := extract(k)
		h = t.seed.bytes(k)
		idx, occupied = searchFuncU32xU32(t, h, k, extract)
	}
	if !occupied {
		ctrl := unsafe2.Cast[unsafe2.VLA[byte]](t.ctrl())
		*ctrl.Get(idx) = h.h2()
		*t.keys().Get(idx) = k
		t.len++
	}
	return t.values().Get(idx)
}

func InsertU64xU32(t *Table[uint64, uint32], k uint64, extract func(uint64) []byte) *uint32 {
	_ = (*Table[uint64, uint32]).Insert
	if t.len == t.soft {
		return nil
	}

	var idx int
	var occupied bool
	var h fxhash
	if extract == nil {
		h = t.seed.u64(zext(k))
		idx, occupied = searchU64xU32(t, h, k)
	} else {
		k := extract(k)
		h = t.seed.bytes(k)
		idx, occupied = searchFuncU64xU32(t, h, k, extract)
	}
	if !occupied {
		ctrl := unsafe2.Cast[unsafe2.VLA[byte]](t.ctrl())
		*ctrl.Get(idx) = h.h2()
		*t.keys().Get(idx) = k
		t.len++
	}
	return t.values().Get(idx)
}

func InsertU8xU64(t *Table[uint8, uint64], k uint8, extract func(uint8) []byte) *uint64 {
	_ = (*Table[uint8, uint64]).Insert
	if t.len == t.soft {
		return nil
	}

	var idx int
	var occupied bool
	var h fxhash
	if extract == nil {
		h = t.seed.u64(zext(k))
		idx, occupied = searchU8xU64(t, h, k)
	} else {
		k := extract(k)
		h = t.seed.bytes(k)
		idx, occupied = searchFuncU8xU64(t, h, k, extract)
	}
	if !occupied {
		ctrl := unsafe2.Cast[unsafe2.VLA[byte]](t.ctrl())
		*ctrl.Get(idx) = h.h2()
		*t.keys().Get(idx) = k
		t.len++
	}
	return t.values().Get(idx)
}

func InsertU32xU64(t *Table[uint32, uint64], k uint32, extract func(uint32) []byte) *uint64 {
	_ = (*Table[uint32, uint64]).Insert
	if t.len == t.soft {
		return nil
	}

	var idx int
	var occupied bool
	var h fxhash
	if extract == nil {
		h = t.seed.u64(zext(k))
		idx, occupied = searchU32xU64(t, h, k)
	} else {
		k := extract(k)
		h = t.seed.bytes(k)
		idx, occupied = searchFuncU32xU64(t, h, k, extract)
	}
	if !occupied {
		ctrl := unsafe2.Cast[unsafe2.VLA[byte]](t.ctrl())
		*ctrl.Get(idx) = h.h2()
		*t.keys().Get(idx) = k
		t.len++
	}
	return t.values().Get(idx)
}

func InsertU64xU64(t *Table[uint64, uint64], k uint64, extract func(uint64) []byte) *uint64 {
	_ = (*Table[uint64, uint64]).Insert
	if t.len == t.soft {
		return nil
	}

	var idx int
	var occupied bool
	var h fxhash
	if extract == nil {
		h = t.seed.u64(zext(k))
		idx, occupied = searchU64xU64(t, h, k)
	} else {
		k := extract(k)
		h = t.seed.bytes(k)
		idx, occupied = searchFuncU64xU64(t, h, k, extract)
	}
	if !occupied {
		ctrl := unsafe2.Cast[unsafe2.VLA[byte]](t.ctrl())
		*ctrl.Get(idx) = h.h2()
		*t.keys().Get(idx) = k
		t.len++
	}
	return t.values().Get(idx)
}

func searchU8xU8(t *Table[uint8, uint8], h fxhash, k uint8) (idx int, occupied bool) {
	_ = (*Table[uint8, uint8]).search
	t.log("search", "h: %v, k: %v", h, k)

	h2 := broadcast(h.h2())
	empty := broadcast(empty)

	p := t.probe(h)
	keys := t.keys()
	for {

		dbg.Assert(p.i <= p.mask, "full table")

		var i int
		var ctrl ctrl
		p, i, ctrl = p.next()

		mask := ctrl.matches(h2)
		t.log("matching", "i: %v, ctrl: %v, h2: %v, mask: %v", i, ctrl, h2, mask)
		if mask != 0 {
			n := i * 8
			for j := range 8 {
				var eq bool
				mask, eq = mask.next()
				if eq {
					k2 := *keys.Get(n)
					t.log("checking", "%v == %v", k, k2)
					if k == k2 {
						t.log("found occupied", "%v,%v = %v", i, j, n)
						return n, true
					}
				}
				n++
			}
		}

		j := ctrl.first(empty)
		if j < 8 {
			n := i*8 + j
			t.log("found vacant", "%v,%v = %v", i, j, n)
			return n, false
		}
	}
}

func searchU32xU8(t *Table[uint32, uint8], h fxhash, k uint32) (idx int, occupied bool) {
	_ = (*Table[uint32, uint8]).search
	t.log("search", "h: %v, k: %v", h, k)

	h2 := broadcast(h.h2())
	empty := broadcast(empty)

	p := t.probe(h)
	keys := t.keys()
	for {

		dbg.Assert(p.i <= p.mask, "full table")

		var i int
		var ctrl ctrl
		p, i, ctrl = p.next()

		mask := ctrl.matches(h2)
		t.log("matching", "i: %v, ctrl: %v, h2: %v, mask: %v", i, ctrl, h2, mask)
		if mask != 0 {
			n := i * 8
			for j := range 8 {
				var eq bool
				mask, eq = mask.next()
				if eq {
					k2 := *keys.Get(n)
					t.log("checking", "%v == %v", k, k2)
					if k == k2 {
						t.log("found occupied", "%v,%v = %v", i, j, n)
						return n, true
					}
				}
				n++
			}
		}

		j := ctrl.first(empty)
		if j < 8 {
			n := i*8 + j
			t.log("found vacant", "%v,%v = %v", i, j, n)
			return n, false
		}
	}
}

func searchU64xU8(t *Table[uint64, uint8], h fxhash, k uint64) (idx int, occupied bool) {
	_ = (*Table[uint64, uint8]).search
	t.log("search", "h: %v, k: %v", h, k)

	h2 := broadcast(h.h2())
	empty := broadcast(empty)

	p := t.probe(h)
	keys := t.keys()
	for {

		dbg.Assert(p.i <= p.mask, "full table")

		var i int
		var ctrl ctrl
		p, i, ctrl = p.next()

		mask := ctrl.matches(h2)
		t.log("matching", "i: %v, ctrl: %v, h2: %v, mask: %v", i, ctrl, h2, mask)
		if mask != 0 {
			n := i * 8
			for j := range 8 {
				var eq bool
				mask, eq = mask.next()
				if eq {
					k2 := *keys.Get(n)
					t.log("checking", "%v == %v", k, k2)
					if k == k2 {
						t.log("found occupied", "%v,%v = %v", i, j, n)
						return n, true
					}
				}
				n++
			}
		}

		j := ctrl.first(empty)
		if j < 8 {
			n := i*8 + j
			t.log("found vacant", "%v,%v = %v", i, j, n)
			return n, false
		}
	}
}

func searchU8xU32(t *Table[uint8, uint32], h fxhash, k uint8) (idx int, occupied bool) {
	_ = (*Table[uint8, uint32]).search
	t.log("search", "h: %v, k: %v", h, k)

	h2 := broadcast(h.h2())
	empty := broadcast(empty)

	p := t.probe(h)
	keys := t.keys()
	for {

		dbg.Assert(p.i <= p.mask, "full table")

		var i int
		var ctrl ctrl
		p, i, ctrl = p.next()

		mask := ctrl.matches(h2)
		t.log("matching", "i: %v, ctrl: %v, h2: %v, mask: %v", i, ctrl, h2, mask)
		if mask != 0 {
			n := i * 8
			for j := range 8 {
				var eq bool
				mask, eq = mask.next()
				if eq {
					k2 := *keys.Get(n)
					t.log("checking", "%v == %v", k, k2)
					if k == k2 {
						t.log("found occupied", "%v,%v = %v", i, j, n)
						return n, true
					}
				}
				n++
			}
		}

		j := ctrl.first(empty)
		if j < 8 {
			n := i*8 + j
			t.log("found vacant", "%v,%v = %v", i, j, n)
			return n, false
		}
	}
}

func searchU32xU32(t *Table[uint32, uint32], h fxhash, k uint32) (idx int, occupied bool) {
	_ = (*Table[uint32, uint32]).search
	t.log("search", "h: %v, k: %v", h, k)

	h2 := broadcast(h.h2())
	empty := broadcast(empty)

	p := t.probe(h)
	keys := t.keys()
	for {

		dbg.Assert(p.i <= p.mask, "full table")

		var i int
		var ctrl ctrl
		p, i, ctrl = p.next()

		mask := ctrl.matches(h2)
		t.log("matching", "i: %v, ctrl: %v, h2: %v, mask: %v", i, ctrl, h2, mask)
		if mask != 0 {
			n := i * 8
			for j := range 8 {
				var eq bool
				mask, eq = mask.next()
				if eq {
					k2 := *keys.Get(n)
					t.log("checking", "%v == %v", k, k2)
					if k == k2 {
						t.log("found occupied", "%v,%v = %v", i, j, n)
						return n, true
					}
				}
				n++
			}
		}

		j := ctrl.first(empty)
		if j < 8 {
			n := i*8 + j
			t.log("found vacant", "%v,%v = %v", i, j, n)
			return n, false
		}
	}
}

func searchU64xU32(t *Table[uint64, uint32], h fxhash, k uint64) (idx int, occupied bool) {
	_ = (*Table[uint64, uint32]).search
	t.log("search", "h: %v, k: %v", h, k)

	h2 := broadcast(h.h2())
	empty := broadcast(empty)

	p := t.probe(h)
	keys := t.keys()
	for {

		dbg.Assert(p.i <= p.mask, "full table")

		var i int
		var ctrl ctrl
		p, i, ctrl = p.next()

		mask := ctrl.matches(h2)
		t.log("matching", "i: %v, ctrl: %v, h2: %v, mask: %v", i, ctrl, h2, mask)
		if mask != 0 {
			n := i * 8
			for j := range 8 {
				var eq bool
				mask, eq = mask.next()
				if eq {
					k2 := *keys.Get(n)
					t.log("checking", "%v == %v", k, k2)
					if k == k2 {
						t.log("found occupied", "%v,%v = %v", i, j, n)
						return n, true
					}
				}
				n++
			}
		}

		j := ctrl.first(empty)
		if j < 8 {
			n := i*8 + j
			t.log("found vacant", "%v,%v = %v", i, j, n)
			return n, false
		}
	}
}

func searchU8xU64(t *Table[uint8, uint64], h fxhash, k uint8) (idx int, occupied bool) {
	_ = (*Table[uint8, uint64]).search
	t.log("search", "h: %v, k: %v", h, k)

	h2 := broadcast(h.h2())
	empty := broadcast(empty)

	p := t.probe(h)
	keys := t.keys()
	for {

		dbg.Assert(p.i <= p.mask, "full table")

		var i int
		var ctrl ctrl
		p, i, ctrl = p.next()

		mask := ctrl.matches(h2)
		t.log("matching", "i: %v, ctrl: %v, h2: %v, mask: %v", i, ctrl, h2, mask)
		if mask != 0 {
			n := i * 8
			for j := range 8 {
				var eq bool
				mask, eq = mask.next()
				if eq {
					k2 := *keys.Get(n)
					t.log("checking", "%v == %v", k, k2)
					if k == k2 {
						t.log("found occupied", "%v,%v = %v", i, j, n)
						return n, true
					}
				}
				n++
			}
		}

		j := ctrl.first(empty)
		if j < 8 {
			n := i*8 + j
			t.log("found vacant", "%v,%v = %v", i, j, n)
			return n, false
		}
	}
}

func searchU32xU64(t *Table[uint32, uint64], h fxhash, k uint32) (idx int, occupied bool) {
	_ = (*Table[uint32, uint64]).search
	t.log("search", "h: %v, k: %v", h, k)

	h2 := broadcast(h.h2())
	empty := broadcast(empty)

	p := t.probe(h)
	keys := t.keys()
	for {

		dbg.Assert(p.i <= p.mask, "full table")

		var i int
		var ctrl ctrl
		p, i, ctrl = p.next()

		mask := ctrl.matches(h2)
		t.log("matching", "i: %v, ctrl: %v, h2: %v, mask: %v", i, ctrl, h2, mask)
		if mask != 0 {
			n := i * 8
			for j := range 8 {
				var eq bool
				mask, eq = mask.next()
				if eq {
					k2 := *keys.Get(n)
					t.log("checking", "%v == %v", k, k2)
					if k == k2 {
						t.log("found occupied", "%v,%v = %v", i, j, n)
						return n, true
					}
				}
				n++
			}
		}

		j := ctrl.first(empty)
		if j < 8 {
			n := i*8 + j
			t.log("found vacant", "%v,%v = %v", i, j, n)
			return n, false
		}
	}
}

func searchU64xU64(t *Table[uint64, uint64], h fxhash, k uint64) (idx int, occupied bool) {
	_ = (*Table[uint64, uint64]).search
	t.log("search", "h: %v, k: %v", h, k)

	h2 := broadcast(h.h2())
	empty := broadcast(empty)

	p := t.probe(h)
	keys := t.keys()
	for {

		dbg.Assert(p.i <= p.mask, "full table")

		var i int
		var ctrl ctrl
		p, i, ctrl = p.next()

		mask := ctrl.matches(h2)
		t.log("matching", "i: %v, ctrl: %v, h2: %v, mask: %v", i, ctrl, h2, mask)
		if mask != 0 {
			n := i * 8
			for j := range 8 {
				var eq bool
				mask, eq = mask.next()
				if eq {
					k2 := *keys.Get(n)
					t.log("checking", "%v == %v", k, k2)
					if k == k2 {
						t.log("found occupied", "%v,%v = %v", i, j, n)
						return n, true
					}
				}
				n++
			}
		}

		j := ctrl.first(empty)
		if j < 8 {
			n := i*8 + j
			t.log("found vacant", "%v,%v = %v", i, j, n)
			return n, false
		}
	}
}

func searchFuncU8xU8(t *Table[uint8, uint8], h fxhash, k []byte, extract func(uint8) []byte) (idx int, occupied bool) {
	_ = (*Table[uint8, uint8]).searchFunc
	h2 := broadcast(h.h2())
	empty := broadcast(empty)

	p := t.probe(h)
	keys := t.keys()
	for {

		dbg.Assert(p.i <= p.mask, "full table")

		var i int
		var ctrl ctrl
		p, i, ctrl = p.next()

		mask := ctrl.matches(h2)
		if mask != 0 {
			n := i * 8
			for j := range 8 {
				var eq bool
				mask, eq = mask.next()
				if eq {
					k2 := extract(*keys.Get(n))
					t.log("checking", "%x == %x", k, k2)
					if bytes.Equal(k, k2) {
						t.log("found occupied", "%v,%v = %v", i, j, n)
						return n, true
					}
				}
				n++
			}
		}

		j := ctrl.first(empty)
		if j < 8 {
			n := i*8 + j
			t.log("found vacant", "%v,%v = %v", i, j, n)
			return n, false
		}
	}
}

func searchFuncU32xU8(t *Table[uint32, uint8], h fxhash, k []byte, extract func(uint32) []byte) (idx int, occupied bool) {
	_ = (*Table[uint32, uint8]).searchFunc
	h2 := broadcast(h.h2())
	empty := broadcast(empty)

	p := t.probe(h)
	keys := t.keys()
	for {

		dbg.Assert(p.i <= p.mask, "full table")

		var i int
		var ctrl ctrl
		p, i, ctrl = p.next()

		mask := ctrl.matches(h2)
		if mask != 0 {
			n := i * 8
			for j := range 8 {
				var eq bool
				mask, eq = mask.next()
				if eq {
					k2 := extract(*keys.Get(n))
					t.log("checking", "%x == %x", k, k2)
					if bytes.Equal(k, k2) {
						t.log("found occupied", "%v,%v = %v", i, j, n)
						return n, true
					}
				}
				n++
			}
		}

		j := ctrl.first(empty)
		if j < 8 {
			n := i*8 + j
			t.log("found vacant", "%v,%v = %v", i, j, n)
			return n, false
		}
	}
}

func searchFuncU64xU8(t *Table[uint64, uint8], h fxhash, k []byte, extract func(uint64) []byte) (idx int, occupied bool) {
	_ = (*Table[uint64, uint8]).searchFunc
	h2 := broadcast(h.h2())
	empty := broadcast(empty)

	p := t.probe(h)
	keys := t.keys()
	for {

		dbg.Assert(p.i <= p.mask, "full table")

		var i int
		var ctrl ctrl
		p, i, ctrl = p.next()

		mask := ctrl.matches(h2)
		if mask != 0 {
			n := i * 8
			for j := range 8 {
				var eq bool
				mask, eq = mask.next()
				if eq {
					k2 := extract(*keys.Get(n))
					t.log("checking", "%x == %x", k, k2)
					if bytes.Equal(k, k2) {
						t.log("found occupied", "%v,%v = %v", i, j, n)
						return n, true
					}
				}
				n++
			}
		}

		j := ctrl.first(empty)
		if j < 8 {
			n := i*8 + j
			t.log("found vacant", "%v,%v = %v", i, j, n)
			return n, false
		}
	}
}

func searchFuncU8xU32(t *Table[uint8, uint32], h fxhash, k []byte, extract func(uint8) []byte) (idx int, occupied bool) {
	_ = (*Table[uint8, uint32]).searchFunc
	h2 := broadcast(h.h2())
	empty := broadcast(empty)

	p := t.probe(h)
	keys := t.keys()
	for {

		dbg.Assert(p.i <= p.mask, "full table")

		var i int
		var ctrl ctrl
		p, i, ctrl = p.next()

		mask := ctrl.matches(h2)
		if mask != 0 {
			n := i * 8
			for j := range 8 {
				var eq bool
				mask, eq = mask.next()
				if eq {
					k2 := extract(*keys.Get(n))
					t.log("checking", "%x == %x", k, k2)
					if bytes.Equal(k, k2) {
						t.log("found occupied", "%v,%v = %v", i, j, n)
						return n, true
					}
				}
				n++
			}
		}

		j := ctrl.first(empty)
		if j < 8 {
			n := i*8 + j
			t.log("found vacant", "%v,%v = %v", i, j, n)
			return n, false
		}
	}
}

func searchFuncU32xU32(t *Table[uint32, uint32], h fxhash, k []byte, extract func(uint32) []byte) (idx int, occupied bool) {
	_ = (*Table[uint32, uint32]).searchFunc
	h2 := broadcast(h.h2())
	empty := broadcast(empty)

	p := t.probe(h)
	keys := t.keys()
	for {

		dbg.Assert(p.i <= p.mask, "full table")

		var i int
		var ctrl ctrl
		p, i, ctrl = p.next()

		mask := ctrl.matches(h2)
		if mask != 0 {
			n := i * 8
			for j := range 8 {
				var eq bool
				mask, eq = mask.next()
				if eq {
					k2 := extract(*keys.Get(n))
					t.log("checking", "%x == %x", k, k2)
					if bytes.Equal(k, k2) {
						t.log("found occupied", "%v,%v = %v", i, j, n)
						return n, true
					}
				}
				n++
			}
		}

		j := ctrl.first(empty)
		if j < 8 {
			n := i*8 + j
			t.log("found vacant", "%v,%v = %v", i, j, n)
			return n, false
		}
	}
}

func searchFuncU64xU32(t *Table[uint64, uint32], h fxhash, k []byte, extract func(uint64) []byte) (idx int, occupied bool) {
	_ = (*Table[uint64, uint32]).searchFunc
	h2 := broadcast(h.h2())
	empty := broadcast(empty)

	p := t.probe(h)
	keys := t.keys()
	for {

		dbg.Assert(p.i <= p.mask, "full table")

		var i int
		var ctrl ctrl
		p, i, ctrl = p.next()

		mask := ctrl.matches(h2)
		if mask != 0 {
			n := i * 8
			for j := range 8 {
				var eq bool
				mask, eq = mask.next()
				if eq {
					k2 := extract(*keys.Get(n))
					t.log("checking", "%x == %x", k, k2)
					if bytes.Equal(k, k2) {
						t.log("found occupied", "%v,%v = %v", i, j, n)
						return n, true
					}
				}
				n++
			}
		}

		j := ctrl.first(empty)
		if j < 8 {
			n := i*8 + j
			t.log("found vacant", "%v,%v = %v", i, j, n)
			return n, false
		}
	}
}

func searchFuncU8xU64(t *Table[uint8, uint64], h fxhash, k []byte, extract func(uint8) []byte) (idx int, occupied bool) {
	_ = (*Table[uint8, uint64]).searchFunc
	h2 := broadcast(h.h2())
	empty := broadcast(empty)

	p := t.probe(h)
	keys := t.keys()
	for {

		dbg.Assert(p.i <= p.mask, "full table")

		var i int
		var ctrl ctrl
		p, i, ctrl = p.next()

		mask := ctrl.matches(h2)
		if mask != 0 {
			n := i * 8
			for j := range 8 {
				var eq bool
				mask, eq = mask.next()
				if eq {
					k2 := extract(*keys.Get(n))
					t.log("checking", "%x == %x", k, k2)
					if bytes.Equal(k, k2) {
						t.log("found occupied", "%v,%v = %v", i, j, n)
						return n, true
					}
				}
				n++
			}
		}

		j := ctrl.first(empty)
		if j < 8 {
			n := i*8 + j
			t.log("found vacant", "%v,%v = %v", i, j, n)
			return n, false
		}
	}
}

func searchFuncU32xU64(t *Table[uint32, uint64], h fxhash, k []byte, extract func(uint32) []byte) (idx int, occupied bool) {
	_ = (*Table[uint32, uint64]).searchFunc
	h2 := broadcast(h.h2())
	empty := broadcast(empty)

	p := t.probe(h)
	keys := t.keys()
	for {

		dbg.Assert(p.i <= p.mask, "full table")

		var i int
		var ctrl ctrl
		p, i, ctrl = p.next()

		mask := ctrl.matches(h2)
		if mask != 0 {
			n := i * 8
			for j := range 8 {
				var eq bool
				mask, eq = mask.next()
				if eq {
					k2 := extract(*keys.Get(n))
					t.log("checking", "%x == %x", k, k2)
					if bytes.Equal(k, k2) {
						t.log("found occupied", "%v,%v = %v", i, j, n)
						return n, true
					}
				}
				n++
			}
		}

		j := ctrl.first(empty)
		if j < 8 {
			n := i*8 + j
			t.log("found vacant", "%v,%v = %v", i, j, n)
			return n, false
		}
	}
}

func searchFuncU64xU64(t *Table[uint64, uint64], h fxhash, k []byte, extract func(uint64) []byte) (idx int, occupied bool) {
	_ = (*Table[uint64, uint64]).searchFunc
	h2 := broadcast(h.h2())
	empty := broadcast(empty)

	p := t.probe(h)
	keys := t.keys()
	for {

		dbg.Assert(p.i <= p.mask, "full table")

		var i int
		var ctrl ctrl
		p, i, ctrl = p.next()

		mask := ctrl.matches(h2)
		if mask != 0 {
			n := i * 8
			for j := range 8 {
				var eq bool
				mask, eq = mask.next()
				if eq {
					k2 := extract(*keys.Get(n))
					t.log("checking", "%x == %x", k, k2)
					if bytes.Equal(k, k2) {
						t.log("found occupied", "%v,%v = %v", i, j, n)
						return n, true
					}
				}
				n++
			}
		}

		j := ctrl.first(empty)
		if j < 8 {
			n := i*8 + j
			t.log("found vacant", "%v,%v = %v", i, j, n)
			return n, false
		}
	}
}

func LookupI32xU32(t *Table[int32, uint32], k int32) *uint32 {
	_ = (*Table[int32, uint32]).Lookup
	h := t.seed.u64(zext(k))
	idx, occupied := searchI32xU32(t, h, k)
	if !occupied {
		return nil
	}
	return t.values().Get(idx)
}

func searchI32xU32(t *Table[int32, uint32], h fxhash, k int32) (idx int, occupied bool) {
	_ = (*Table[int32, uint32]).search
	t.log("search", "h: %v, k: %v", h, k)

	h2 := broadcast(h.h2())
	empty := broadcast(empty)

	p := t.probe(h)
	keys := t.keys()
	for {

		dbg.Assert(p.i <= p.mask, "full table")

		var i int
		var ctrl ctrl
		p, i, ctrl = p.next()

		mask := ctrl.matches(h2)
		t.log("matching", "i: %v, ctrl: %v, h2: %v, mask: %v", i, ctrl, h2, mask)
		if mask != 0 {
			n := i * 8
			for j := range 8 {
				var eq bool
				mask, eq = mask.next()
				if eq {
					k2 := *keys.Get(n)
					t.log("checking", "%v == %v", k, k2)
					if k == k2 {
						t.log("found occupied", "%v,%v = %v", i, j, n)
						return n, true
					}
				}
				n++
			}
		}

		j := ctrl.first(empty)
		if j < 8 {
			n := i*8 + j
			t.log("found vacant", "%v,%v = %v", i, j, n)
			return n, false
		}
	}
}

func searchFuncI32xU32(t *Table[int32, uint32], h fxhash, k []byte, extract func(int32) []byte) (idx int, occupied bool) {
	_ = (*Table[int32, uint32]).searchFunc
	h2 := broadcast(h.h2())
	empty := broadcast(empty)

	p := t.probe(h)
	keys := t.keys()
	for {

		dbg.Assert(p.i <= p.mask, "full table")

		var i int
		var ctrl ctrl
		p, i, ctrl = p.next()

		mask := ctrl.matches(h2)
		if mask != 0 {
			n := i * 8
			for j := range 8 {
				var eq bool
				mask, eq = mask.next()
				if eq {
					k2 := extract(*keys.Get(n))
					t.log("checking", "%x == %x", k, k2)
					if bytes.Equal(k, k2) {
						t.log("found occupied", "%v,%v = %v", i, j, n)
						return n, true
					}
				}
				n++
			}
		}

		j := ctrl.first(empty)
		if j < 8 {
			n := i*8 + j
			t.log("found vacant", "%v,%v = %v", i, j, n)
			return n, false
		}
	}
}
